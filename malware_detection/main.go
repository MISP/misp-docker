package main

import (
	"bufio"
	"bytes"
	"compress/gzip"
	"crypto/md5"
	"encoding/csv"
	"encoding/hex"
	"fmt"
	"io"
	"io/fs"
	"math"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
	"unicode"

	"github.com/spf13/cobra"
	"github.com/tj/go-spin"
)

const (
	// metadata
	APP_NAME  = "webshell-detector"
	ISSUER    = "ITEASY"
	VERSION   = "0.0.1"
	CREATEDAT = "2025-02-24"

	// SCORE OF WEBSHELL
	SCORE_DANGER = 100
	SCORE_INIT   = 0

	// THRESHOLD
	THRESHOLD_ENTROPY      = 4.0
	THRESHOLD_IoC          = 0.05
	THRESHOLD_LONGEST_WORD = 30
	THRESHOLD_SIGNATURE    = 2
	THRESHOLD_COMPRESSION  = 0.8
	THRESHOLD_USING_EVAL   = 1

	// WEIGHT
	WEIGHT_ENTROPY      = 20
	WEIGHT_IoC          = 15
	WEIGHT_LONGEST_WORD = 10
	WEIGHT_SIGNATURE    = 25
	WEIGHT_COMPRESSION  = 10
	WEIGHT_USING_EVAL   = 20

	// Print
	DEFINITELY       = "üö® ÌôïÏã§Ìïú ÏõπÏâò"
	ALMOST_CERTAINLY = "‚ö†Ô∏è Í≥†ÏúÑÌóò ÏõπÏâò ÏùòÏã¨"
	PROBABLY         = "‚ö†Ô∏è Ï§ëÍ∞Ñ ÏúÑÌóò ÏõπÏâò ÏùòÏã¨"
	MAYBE            = "‚ùì Ï†ÄÏúÑÌóò Í∞ÄÎä•ÏÑ± ÏûàÏùå"
	DOUBTFULLY       = "‚úÖ Ï†ïÏÉÅ ÏΩîÎìúÎ°ú ÌåêÎã®"

	// MISP DATA
	FETCH_URL_OF_ITEASY_MISP = "http://localhost:8888/getWebShellListSHA265"
	PING_URL_OF_ITEASY_MISP  = "http://localhost:8888/health"

	// LOG_LEVEL
	LOG_LEVEL_ALL           = 0
	LOG_LEVEL_IGNORE_NORMAL = 1
	LOG_LEVEL_DEFINITELY    = 2

	// ANSI COLOR
	InfoColor    = "\033[1;34m%s\033[0m\n"
	NoticeColor  = "\033[1;36m%s\033[0m\n"
	WarningColor = "\033[1;33m%s\033[0m\n"
	ErrorColor   = "\033[1;31m%s\033[0m\n"
	DebugColor   = "\033[0;36m%s\033[0m\n"
)

var signatures = []string{"eval", "base64_decode", "assert", "exec", "shell_exec", "system", "passthru", "popen", "proc_open"}
var targetPath, outputPath string
var isDebug bool
var logLevel int16

// TODO: Ï∂îÌõÑ ÏóÖÎç∞Ïù¥Ìä∏
var skipDIR []string

// This is Local Data
// from https://github.com/tennc/webshell/tree/master/php
var public_webshell_signature_md5 = `
4745d510fed4378e4b1730f56f25e569
272dde9a4a7265d6c139287560328cd5
5cd409f4f88fcdacf162a0860cb1b8fc
70ea3ee42290cabf7079c185d466d0f0
fbf2e76e6f897f6f42b896c855069276
acdbba993a5a4186fd864c5e4ea0ba4f
e2830d3286001d1455479849aacbbb38
9fa6e5899e9cc8a868dfdaa31e2d58a0
c8b244a825e1d049b07a661536558e47
9f21edf1802fb54dc38506ee13f3c50f
fd69c867e13f2e4eabde3dbf298edeb4
6528cc002029c69e5fd89d6434e3a927
6e42f85f6676fbc4bf8bec75d24d69c1
565d7e3411a3b0a555387087cb2d1439
472e26dc05dd5dd1cc887136cb53a553
900635766d42a83a02974e034f41ce08
b4f555c7128eb94e65913ee59b3e0ee2
ce94f7044d19fc86035be8fc850c2dda
802c8edeb7746fa82097db3f868d8767
cc3db0ee972afbea2632b96f8e3cd0a6
e9f3cef8e9e68234ef7e80cc37f7dc9f
8fac41fdc2c5363bffa85f9cfaa1b389
e850649aba473c8fbc5f5df8fa0b4880
d87b019e74064aa90e2bb143e5e16cfa
197d4f0654faccef107faa3026487a13
bc2039fb3c8477149fe44c2d5fe4b897
8d435457a4ccaaa8fad4afd405e95088
19bbee91c51293f996b81054a7306be2
9b795afa8397ac0281c31398273e28b6
e20a3556c6b42ccc15163be62dd67581
9e7b7d7986f057b2dae4246ed4e1fea5
20ede5b8182d952728d594e6f2bb5c76
d2b98ee660d8dcc00333cc29e428eb38
3df2d88a7c3798503be8ffb89590c12b
648c6f92b8c66c547a6fc49f51f9f875
4f98dc5431188f83ada90294b2ceb871
bc0090c4ea1dc9b744422b2c2be1802c
d76dc20a4017191216a0315b7286056f
8ee83b69a6a150c42c6f451eedf95ca2
f7f1328a6ddb481368aa24a9d29762f9
aa17b71bb93c6789911bd1c9df834ff9
61ffb42af36cd85640e3340278a6196a
78b8a6ad5c0e1bc162638574bcbb49f2
fdbf54d5bf3264eb1c4bff1fac548879
799a50baa8d5a063cd1f96333efc3e07
55e3aca267333fa2fdffa5e3c2152cbb
e67ef9481220842444ab0c69dfb7e0b5
127b2a5db04e6ff28716e766793497ac
a4a6e8ef1a5da87dc34f38c8fd327f1a
dc91bbe5c9c46fd6d7784be013750989
bb5a86067a5a5ba36f94fb3b330ad6a1
aad40125e7ad449b915b9f177960091a
a7fe5f28df56d66e43dcd3b92f024113
3f63e22f57d872da8c564416dccc280d
40a1f840111996ff7200d18968e42cfe
20d9a09b7c3900908b3dce59c3d13516
da3341a2798a51e332c03e352014547b
afcdc70f6890eb192763b8a69791df7d
9ad34b44993ec691db1a5edb58ca4cd8
48ca18a25424a0f52276290b619a7a83
f3246cd660c5cb9df0f54fa178c595ff
af98811db11595148eec31e3bc1d5502
5d8d56a7d8049a17f10a243c17181f07
abc027eb6bf8979012986316f83256ac
fc0a162ef6f1b8238a5531cd9bbc9938
50d8acd511479afbffc1227b315edb4b
36250e0b627db3501e8e72c85eb7aa42
3311004d7a112de83065c23ab2c7b116
73d6ea56610d72c9398836f8beaaeba6
7646230b5ddcc7286450bbad8e6800d5
088cafc09d17f2a26981f1d39818bc92
2782bb170acaed3829ea9a04f0ac7218
00898cbc3a95544865c6ef3f6dba7506
a3e6d7d37079dbefc5d9d3bdb8936173
cf01cb6e09ee594545693c5d327bdd50
a9c13aac6cec12ab01ef589e73ea7a6e
ced050df5ca42064056a7ad610a191b3
818bbe96bf23968f483924dd52ac5e17
369c50566ca0f5d05cdad280581930ca
0723362e176328b2e98e99ac6cc17884
a8431daa505548467a0beeda8039bc6b
72d1df71c41c6711ca5ba026c59ccb82
93a444be22ab85d2d4ed0c95ef7acc55
daab57846ab4a4a4ab7a7e42f493b6ec
29420106d9a81553ef0d1ca72b9934d9
8cbd608dbab94bf398fe43cdfc1d1542
160b79990b5a72f3b08f5055d4488a79
32abdc81d5225558a398806c9f31992f
0b034fb1a707e4539d5d99c4f65eda0a
25284d1fd71b11a5769ec4f9c32c8c98
f5985dd7ef020dee7432156f4ab463b9
11c9ca06fa172f4631821825c819d346
2d7591ab73d1ae5dcce30b5c9a7ea917
2abd681c2c490c6617493c4f83feb68f
dd643a6dacf4f922c60669d3211645eb
7a46ddd03955d7fc7d021dca20abde05
9f1b15b11b1c6bff086176ca472a65d2
48bcbbab1c1aa67777df8b179e3a05b4
493e016593ac0fe2dba90e1f6776e9cc
513b7be8bd0595c377283a7c87b44b2e
d7b955b73a3d24c39d43ceb0b597f87d
b2e1643489ddbdca5e1a4ae06e581cad
0fa288f0c0a5187f9dda24ece99f34ec
f8746f252b1963449d89c76a4dd4779b
85036075e21ad54b5a64d1859b90060e
1f9aa301220e168438f48ddb025314c2
3a45576d4fb741d1388074e0234d9100
58a3129585e36d0fc447d0893bc53da8
a524e7ae8d71e37d2fd3e5fbdab405ea
e37bae567b320664192c860cbd9f4e68
967dc4a0d0f104b52cd5fcd9581c9e06
d755b10656e7b2914fd4b445398dd9fc
4982110c698598ef223993c6d064b534
0385a185f77b0729a00ac2407263e2f5
57416250665fce5a75cf937662bd0189
e26357ed1d2b65426d9d7c4d4816177e
0b0698a1821669b7eecb0d564e528efc
0b7c3457de2369c42e6ccc2a7838ed06
0d7dabc8dddd29c0ea7268d774dd18fc
285d9bf132b086b6b221b9f7ecfaca07
9795d4dd5c2656d746525a54417086ef
e62f1a7a1cc3e0898932d8f019d59645
ec28e3fa5445964981210a15db1606bc
a40c4884b821fffbd93c7efdfdeaba72
8ec2f7c69693c8ec26b53fb061d57695
7b9b2c922f447cf57792d482349805bd
999e705201d8ab11747598d1b07fcb92
5184aa324fa5375cb290d77a6cd0ef5f
7da93f0661aa06e4e1ea52c9d0d4809c
7c5b1b30196c51f1accbffb80296395f
0daa83980af32d11f9c2305d3972a276
5037ab002c7200f8285534ba9310bc84
3d52c6519ee675030ca8abb9ffbbd24c
44a93ee0f79a1d40125ed8aa960f1cbb
23f714c6e96d444b72c6bb6008adfde0
9a0f98582165d2e1ca5a5f88fc8c912b
42f211cec8032eb0881e87ebdb3d7224
3b6013b3e9ec147f00de99feedbc7172
6842841f4b74c9a451548baa08fafa2a
6ef8b1009533cac696122381bd966f88
4d98130356cf3444ead7ec40be2408e0
a2f8fa4cce578fc9c06f8e674b9e63fd
c2dba77eaa9553d26656ea55b4a0a7cf
1630d2ee4b843b4a50e480dda63017f3
07d8298116bf082798db968b12ba7e28
89194577ec4e9d95cb7c54750a79f042
14c7281fdaf2ae004ca5fec8753ce3cb
dbc4051f98a9a443053805d8164d13c2
7cfedd3b6049c285df4f4ef211d9a330
67c48b6129016b77289796b1958e6cd8
0396bb6a40b74c40fb260aa80525c86f
f246766b14020b6d186a7b30303aa24f
79b22d7dbf49d8cfdc564936c8a6a1e2
d38920b1f6aa9bcc976df1f350e5963f
7a49b07d45a2c676567136d2d181cd39
8421dbc286d27630ee1316e2702bede0
a0f9f7f5cd405a514a7f3be329f380e5
b87b3c6cc78d0f0d6eb2e9e73af825e0
c40fcd4d26a5c3fdf1f3c88956308b65
e41a9e5a11f1616d51b86dfdcae1d869
3aaa8cad47055ba53190020311b0fb83
6793d8ebab93e5a0f91e5a331221f331
9de910c63f3ad6c04336045c9915d51c
57824a8e01a93516ae1ecd2484a8bf23
a2516ac6ee41a7cf931cbaef1134a9e4
4108f28a9792b50d95f95b9e5314fa1e
591a4b3fd93e5aa41b891d75b6929671
25256f33e77f4b409f925a1adcb009b9
8c765dd11adacdc4e8aebda8484c349c
23a01eb898454f6bea5cf164276a3720
a12fc0a3d31e2f89727b9678148cd487
62af9f9e6ac3dbddafe6434431409571
a8431daa505548467a0beeda8039bc6b
7582e8715b6d090dc8dc0d2cfe833096
4d56b57c0e93e6ff9abee0a536eb8a4f
eed4e41ce381ba1598aad680b5466a56
01011ab7ec54265837d57803d4a9dd62
104f29cd2d078166cff495581fd55be5
e5b2131dd1db0dbdb43b53c5ce99016a
8dcef91c6304f51748b8decca5267ef3
6e1a88e0ab05e9dca8194b624500b528
4ea2d3f540882bdf49ac4b8c987e493b
c6ede92f82c0257bfb0e9e5479d3ce51
026de8f85fdb4c9a87da387e0f6d2eb7
c8e83cf48cae9f3d4afbe93632380e53
6ab5e329bf6e0060d9f494beb4d22bb4
b46b66c970e3957db2d7441e767cd67a
22f2223f56187549835e8b7f69476037
0e71428fe68b39b70adb6aeedf260ca0
774676832d10fcfb77e696c8021bb3bd
1c09fdb4f33aca3bf036cbfe5f079867
8ae9d2b50dc382f0571cd7492f079836
6056bcc4ac2f6a1a4ade3a44821f1785
61a92ce63369e2fa4919ef0ff7c51167
da5e0da563c5a1dc2fcc7123ce247814
1da385d0d74c507a51c99a97eec799b5
0e2fc1a664b026f5736dd7e369248ad0
2daecae6aac185548df7f18d7095edeb
7d16b5bb613afc4445eef1739e96b20c
feb123e9fbe859c250085312141f9bad
dac1ecd180adc37ecff55b682ca68d52
2033a3657b8738773ad43583f79b7ebe
12911b73bc6a5d313b494102abcf5c57
ba120abac165a5a30044428fac1970d8
175a9172b73a7d6df9d737de7b355a48
d81797a68a7e446f7e83a39dbd0f5cba
a48e0f6c6cbe6a3551630d81f48da13c
4fcc7b4c9c8c18ad749012774c1dc57e
61d53812c6fa5fe5b8881ae5f971014d
02e38ef6bea711672469d0163bd250b7
caaa4ee6a9712431699e8e25577f9205
ce4e05261668165fef949b1408144806
671cad517edd254352fe7e0c7c981c39
e78f48f298f3869961be2228df3764f7
9af195491101e0816a263c106e4c145e
a89a639b05fb210af6e2b0914cc1a8d2
672030606c5206b1f74cffefe50ceae6
b53d57750063b5d2622e6757f3001e31
0bd88b38f27318424a9d0731bba15277
c0dc51d5c2bd79f772668e063fca8cf5
6c6541721169df85d6d310c7d80a0a6b
1d885d1378c8b9e467ceebfe7976fd76
6d8feab2580671a8a8e6e68bce4bd01c
14ae0e4f5349924a5047fed9f3b105c5
ceea79629a2ff0c79143b4e12e7b01ea
dbeecd555a2ef80615f0894027ad75dc
c93f89c1c6a9e35b100f18451b2a0837
5295ee8dc2f5fd416be442548d68f7a6
1606bdac2cb613bf0b8a22690364fbc5
1fb32f8e58c8deb168c06297a04a21f1
0d8eac7c8d9cc79cc0e8a61a58559576
124841df98da5cdb6ff747c240c3612d
6e31d8f7920be6a7bb1c3b7fb36bddb4
d722d996fe3254a5f3909de31047dbdc
9c392471ef2453d91ab6e7be9d1278a8
3df4ef9b35927945854997b9605b1620
3e4ba470d4c38765e4b16ed930facf2c
b68bfafc6059fd26732fa07fb6f7f640
49c9198ab03fb25f76004be21b05ae52
7a480866939f81bd98a0fa3a5b976b7b
76117b2ee4a7ac06832d50b2d04070b8
b8badb18af0fa1503fe32f0df1cc403e
1a94cfd9f0d63e12661ebe051c5a23ed
8b01f44271094a474d76ad4537250413
449a2aef83d79db573eab8f05eebb37e
a18a1bc5e9e40812a438d6816e020378
1083f2634d1e672d6a427a081e577cad
59d15ebbe1d262603119f286c6c32f16
ef43fef943e9df90ddb6257950b3538f
2f66404cdcd4024ee5c1d73dd8c47273
0dd3fb9752d8dc5b29cc98f376dda825
d195080cf419a3ec0b8cbcab97f617dd
ba7473f3410cc51f4bb27fa5e0cdd106
4241ed910406403266ae572d4da9014a
4b50a2f633b54ebecc1916e70e11bf6f
dc20eeca5d5b26ca270f6a703b8b79ed
a89c5695992c26b5345d6fe136c78776
3fef3693f3692053e33876c1b56aef25
59d9dd1c7efa58dbec5a72a365022481
b4d3b9dbdd36cac0eba7a598877b6da1
e96634f41e52d5529291da0fcb53eda3
5c9367b2f64c1608d0e5a4aa4684d4d9
35fb37f3c806718545d97c6559abd262
9c34adbc8fd8d908cbb341734830f971
b23c7cdc258af4ec0fcabb1f6175de1b
f16ad66813adb7000a73f9d2929f73e6
d539eefaf258fdf80652e503d4cfad3f
3f4d454d27ecc0013e783ed921eeecde
9bd9880089256dca5bf7e295961536ca
67da91cc65232373597d8d983e36a07c
9cfe372d49fe8bf2fac8e1c534153d9b
38fd7e45f9c11a37463c3ded1c76af4c
74e1e7c7a6798f1663efb42882b85bee
b7c72337c4bf8af12635a23a46125d0d
a444014c134ff24c0be5a05c02b81a79
5542787bb021dd54dbd7c45d2917facd
c98b3d7d977ce9f54116d6493b7aaa56
c805d3948595794c70d4b34c0dd834ad
36d4f34d0a22080f47bb1cb94107c60f
edbd7adb9150e14238d9b5fb2a9301d3
3c30399e7480c09276f412271f60ed01
d0005805094e03f6c226cce5895878b3
b72a26901c9d3ba68ad56540836ad280
59281e41b9ffe118e8b331b65ba82c6b
6e38561b7f1a3613283b0d2398690c68
b3b1e08864b97c18675d60802e2d85b1
c4b382f504315f3ba5a2d867107b3a92
ec4a86bada22382a25772caac2df4634
bd83144a649c5cc21ac41b505a36a8f3
9d95820688eecd046a7d8caff7040534
993b9c1afdba4d633d5d407c5682ca76
c844f3d8e8e80445e59275275d1068e9
114a6e1af023bbccd9392936855df8cc
b659da4c4ac7d7d8fadafc5596d5a18a
d9de81093a71298408eeb763e988f352
bb8e3afea48be79ca833abb6c1ee7658
7517513dc60a0743f9618a4a41042f9d
de75843f673a5edd21489f6690a29c35
791708057d8b429d91357d38edf43cc0
4155e63948ea22ed67d6d91037e7cf9b
c9ee02069aa00b2b26d7b92a1ebd7ba6
13a0c38ec6d8b21c54d2337cf2e02f40
83bbbfbd04861a69617424c1ce7bf2b6
c4d36c011f6637b4c950740f9542c376
70523edfee6c387ed98472ce751680f0
b4ce5a9d930019b41fb039cc48c2fadc
a9decc995c3c930ac068edcf59b3b9a6
55ad9309b006884f660c41e53150fc2e
a0a85d38f8a3d40ca03dbfac51c6f89b
6d24553d19d35868c066a08fe41861be
3c30399e7480c09276f412271f60ed01
9afa248931e0ea8cb53adb8de3a84c1d
e5a7f5632afa70f14353bf0cd34e6390
0ba2797e1efa862a3c1a246dfe12f7e5
fe6ece01a3b6228e59f9154cceb0a27b
0b19e9de790cd2f4325f8c24b22af540
89f55f70b0af413136954f15b55e08dd
ce969ba4994bb473cbb7cfc5e77f3385
0bd383d71e95f0c28eb4fff2fb1ad03b
7b79d1fd5a9eb6ef296e7ac7082acc54
1185434d34273cbb4ebff866697425dd
cc396a21cfbc4d23b503755d98b448ca
911195a9b7c010f61b66439d9048f400
e23c07f9da000c044a926876b246d8db
f47a44b26f8b67674cc9f254b33af197
f63e099f3a10c500be8398ef803931d0
cbb4cec65a991fba7e7d78a5e27f58b7
8bfa2eeb8a3ff6afc619258e39fded56
1d912c55b96e2efe8ca873d6040e3b30
437d30c94f8eef92dc2f064de4998695
ec13ab978ad85f7465e5fa7ec74352bb
3bd217276e2f799bd64d92e3e75c443f
4ccbcd5f535db11e49f1d427c6653022
31cf895da88f0d3616b0da19864180d3
b0e842bdf83396c3ef8c71ff94e64167
cf2ab009cbd2576a806bfefb74906fdf
67dc3c14fe0d13352d155707943cb7ce
61d458119ef55448e2716a4e1de488a2
8d51ec2f23d01204ba2cd19b5ab52a9b
697dae78c040150daff7db751fc0c03c
638456642e4947bb14e5ad596116d6c7
7a4cf554897c150b915d48ccb774e292
92063b6c7e619045102d4326d3ba2e5c
6e56cd837863b2bde08650908cedf4bc
a89f9aabcfdcb815938ae6a42b0b539a
0176c418103fe6acff9b0845429abb52
f518f9f752c3ba38afb91512da758517
bfbcf7566485a1e1d3627b093096aed2
2e89498399e6276eabc932d90a8f542e
9e1a98fb3f02281e8a483fe2e4de25d5
fdb6145282d7cac82a66ba7fde27f2bf
029bf20f372f67c6c2b575e77baacace
8874363d5b348963927c7f517f85dd86
c6a7ebafdbe239d65248e2b69b670157
90208b0d9682a2e0adf2a5c017c2cf88
9204d55a91c95a3965e138e7960e4b1f
9305d71f61bdfe96c8ace7a31a006c72
27b1130fa91325686b8177d31f74dcc1
41a93270fb72a27923ecfef470029542
dd7a3c81160d05f71ef736de99a9f352
fb3d9a083bd620a4a9418ff05d488a4d
2cc46d91f555c6767cf44511a4d46804
797af1e909aa1c7547d14d2d98f3ce2c
387bd3e8fad98d85b5b7690561451051
1f41ffa4ac622d0952bc3104b393365b
be4fdb6f20cd3c596990c9252ecced6f
b157382351b17ea3ee889ba29c23555d
1da8ceb757a41e8be291af060e639c73
8b3677d980d56dd6177919efa467f550
59509183dde2d83e5e1867be2409655d
4f9f1f898808a53581fcbcb095d00436
48ca18a25424a0f52276290b619a7a83
521275fa6348677fa47ade0e8b770c8b
90fe143035d9ac3277d9c76da0e85c05
7ed63176226f83d36dce47ce82507b28
2998de8b29315b51638a25eb0a1dc318
5bcba70b2137375225d8eedcde2c0ebb
83160460fe3bd3bd22ee6ea4d28aeed0
cbf64a56306c1b5d98898468fc1fdbd8
1046ff57eab801b22b7c7e1c6d5d9da5
4e92d2776f53e915faa37fe1f2058bb9
c5b88a49de687a0b2f73899c154c5b7f
d09f545ab96690e7d66c740ec421a925
4a6e6e5df53429c1901ed85947102e75
5931a716711cbd98ca0c24e7e64c05b0
95fc76081a42c4f26912826cb1bd24b1
567a754992e53687d91c733be6b1075a
eda02ae6dd7d0fe841653f5e6a69d17e
76362b8a2d0cb2effe54e888e089e5be
ee531f568b73b3cce62e274c00cfdb33
cf37833c6c6e603e1d3be1a9056a1ebf
2da34b14c430db432fa254c8d0cbbacb
594d1b1311bbef38a0eb3d6cbb1ab538
4e31daece127e1781d6ff7b6da4b351c
bf584e2accafb5cec00ea349772ea5f8
ff22d78916df7e71539e821c151ba196
8f0e4d24109702b0b15b701ed4073630
d3266ecc6f21f806b4d7bbdeb1a23ed0
ae025c886fbe7f9ed159f49593674832
412573e777294b23912e25d846558df1
f3990fb8a258b52a0b6d5b1c9e4eab29
38dc8383da0859dca82cf0c943dbf16d
fc9ee73ef095004a32cf71cc186dabd0
1dedc596a2b5b090a07464372772f477
`

type Set[T comparable] map[T]struct{}

func NewSet[T comparable](values []T) Set[T] {
	set := make(Set[T])
	set.Add(values)
	return set
}

func (s Set[T]) Add(values []T) {
	for _, value := range values {
		s[value] = struct{}{}
	}
}

func (s Set[T]) Remove(value T) {
	delete(s, value)
}

func (s Set[T]) Contains(value T) bool {
	_, exists := s[value]
	return exists
}

func (s Set[T]) Size() int {
	return len(s)
}

func (s Set[T]) ToSlice() []T {
	slice := make([]T, 0, len(s))
	for value := range s {
		slice = append(slice, value)
	}
	return slice
}

type Analyzer struct {
	text  string
	score int
}

func NewAnalyzer(text string) *Analyzer {
	return &Analyzer{
		text:  text,
		score: SCORE_INIT,
	}
}

// üîπ Shannon Entropy Í≥ÑÏÇ∞
func (a *Analyzer) calculateEntropy(text string) float64 {
	freq := make(map[rune]float64)
	length := float64(len(text))

	for _, char := range text {
		freq[char]++
	}

	var entropy float64
	for _, count := range freq {
		p := count / length
		entropy -= p * math.Log2(p)
	}

	return entropy
}

// üîπ Index of Coincidence Í≥ÑÏÇ∞
func (a *Analyzer) indexOfCoincidence(text string) float64 {
	freq := make(map[rune]int)
	N := len(text)

	for _, char := range text {
		freq[char]++
	}

	var ic float64
	for _, count := range freq {
		ic += float64(count * (count - 1))
	}

	return ic / float64(N*(N-1))
}

// üîπ Í∞ÄÏû• Í∏¥ Îã®Ïñ¥ Í∏∏Ïù¥ Í≥ÑÏÇ∞
func (a *Analyzer) longestWordLength(text string) int {
	words := strings.FieldsFunc(text, func(c rune) bool {
		return !unicode.IsLetter(c) && !unicode.IsNumber(c)
	})

	maxLength := 0
	for _, word := range words {
		if len(word) > maxLength {
			maxLength = len(word)
		}
	}
	return maxLength
}

// üîπ ÌäπÏ†ï ÏãúÍ∑∏ÎãàÏ≤ò Îì±Ïû• ÌöüÏàò Í≥ÑÏÇ∞
func (a *Analyzer) countSignatures(text string) int {
	count := 0
	for _, sig := range signatures {
		count += strings.Count(text, sig)
	}
	return count
}

// üîπ ÏïïÏ∂ï ÎπÑÏú® Í≥ÑÏÇ∞
func (a *Analyzer) compressionRatio(text string) float64 {
	var buf bytes.Buffer
	writer := gzip.NewWriter(&buf)
	writer.Write([]byte(text))
	writer.Close()

	compressedSize := float64(buf.Len())
	originalSize := float64(len(text))

	return compressedSize / originalSize
}

// üîπ eval() ÏÇ¨Ïö© ÌöüÏàò Í≥ÑÏÇ∞
func (a *Analyzer) countEvalUsage(text string) int {
	count := 0
	lines := strings.Split(text, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "eval(") || strings.Contains(line, " eval(") {
			count++
		}
	}
	return count
}

func (a *Analyzer) Run() {
	if a.calculateEntropy(a.text) > THRESHOLD_ENTROPY {
		a.score += WEIGHT_ENTROPY
	}
	if a.indexOfCoincidence(a.text) < THRESHOLD_IoC {
		a.score += WEIGHT_IoC
	}
	if a.longestWordLength(a.text) > THRESHOLD_LONGEST_WORD {
		a.score += WEIGHT_LONGEST_WORD
	}
	if a.countSignatures(a.text) > THRESHOLD_SIGNATURE {
		a.score += WEIGHT_SIGNATURE
	}
	if a.compressionRatio(a.text) > THRESHOLD_COMPRESSION {
		a.score += WEIGHT_COMPRESSION
	}
	if a.countEvalUsage(a.text) > THRESHOLD_USING_EVAL {
		a.score += WEIGHT_USING_EVAL
	}
}

func (a *Analyzer) Score() int {
	return a.score
}

type iSpin interface {
	exec() error
}

type iDebugger interface {
	info() // print object info to console.
}
type iDetection interface {
	init() error    // Initializing Data
	analyze() error // Compare md5 with signature
	output() error  // write logs
	exec() error    // Run Detection
	info()
}

type Detection struct {
	set        Set[string] // signature
	fetchUrl   string
	root       string         // filepath
	hashes     map[string]int // map[filepath]score
	isInternet bool           // is it able to misp connection?
}

func NewDetection(root string) *Detection {
	d := Detection{
		fetchUrl:   FETCH_URL_OF_ITEASY_MISP,
		root:       root,
		hashes:     make(map[string]int),
		isInternet: Ping(),
	}
	return &d
}

func (d *Detection) _setOsintData() error {
	reqBody := bytes.NewBufferString("Post plain text")
	resp, err := http.Post(d.fetchUrl, "text/plain", reqBody)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	// Response Ï≤¥ÌÅ¨.
	respBody, err := io.ReadAll(resp.Body)
	if err == nil {
		str := string(respBody)
		split := strings.Split(str, "\n")
		d.set.Add(split)
	}
	return nil
}

func (d *Detection) _setLocalDate() {
	split := strings.Split(public_webshell_signature_md5, "\n")
	d.set = NewSet(split)
}

func (d *Detection) _setHashes() error {
	var f os.FileInfo
	var err error
	if f, err = os.Stat(d.root); err != nil {
		return err
	}
	if f.IsDir() {
		// dir
		subDirToSkip := "skip" // Ïä§ÌÇµÌï† Ìè¥Îçî
		err = filepath.Walk(d.root, func(path string, info fs.FileInfo, err error) error {
			if err != nil {
				return err
			}
			// TODO: Ï∂îÌõÑ ÏóÖÎç∞Ïù¥Ìä∏
			if info.IsDir() && info.Name() == subDirToSkip {
				return filepath.SkipDir
			}
			// TODO: phpÎßå Í≤ÄÏÇ¨ÌïòÏßÄÎßå Ï∂îÌõÑÏóê Î≤îÏúÑÎ•º ÎÑìÌûê Í≥ÑÌöç
			if !info.IsDir() && strings.Contains(info.Name(), ".php") {
				d.hashes[path] = SCORE_INIT
			}
			return nil
		})
		if err != nil {
			return err
		}
	} else {
		d.hashes[f.Name()] = SCORE_INIT
	}
	return nil
}

func (d *Detection) init() error {
	var err error
	if !strings.Contains(outputPath, ".csv") {
		outputPath = fmt.Sprintf("%s.csv", outputPath)
	}

	_ = os.Remove(outputPath)

	d._setLocalDate()
	if d.isInternet {
		if err = d._setOsintData(); err != nil {
			return err
		}
	}
	if err = d._setHashes(); err != nil {
		return err
	}
	return nil
}

func (d *Detection) _toMD5(data []byte) string {
	hasher := md5.New()
	hasher.Write(data) // Ïù¥ÎØ∏ ÏùΩÏùÄ Îç∞Ïù¥ÌÑ∞Î•º Ìï¥Ïãú Í≥ÑÏÇ∞
	return hex.EncodeToString(hasher.Sum(nil))
}

func (d *Detection) analyze() error {
	// Îßµ ÏàúÌöåÌïòÎ©¥ÏÑú ÏàúÏ∞® Í≤ÄÏÇ¨
	// k = file path
	// v = score
	for k := range d.hashes {
		content, err := os.ReadFile(k)
		if err != nil {
			return err
		}

		md5 := d._toMD5(content)

		if d.set.Contains(md5) {
			d.hashes[k] = SCORE_DANGER
		} else {
			a := NewAnalyzer(string(content))
			a.Run()
			d.hashes[k] = a.Score()
		}
	}
	return nil
}

func (d *Detection) writeLog(wr *csv.Writer, filterFunc func(int) bool) {
	for k, v := range d.hashes {
		if filterFunc(v) {
			if err := wr.Write([]string{k, strconv.Itoa(v), getResult(v)}); err != nil {
				panic(err)
			}
		}
	}

	wr.Flush()
	if err := wr.Error(); err != nil {
		panic(err)
	}
}

func (d *Detection) output() error {
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	wr := csv.NewWriter(bufio.NewWriter(file))

	err = wr.Write([]string{"Name", "Score", "Result"})
	if err != nil {
		return err
	}

	var filterFunc func(int) bool

	switch logLevel {
	case LOG_LEVEL_IGNORE_NORMAL:
		filterFunc = func(score int) bool { return score >= 50 }
	case LOG_LEVEL_DEFINITELY:
		filterFunc = func(score int) bool { return score >= 100 }
	default:
		filterFunc = func(score int) bool { return true }
	}

	d.writeLog(wr, filterFunc)
	return nil
}

func (d *Detection) info() {
	fmt.Printf("Amount of Public Signatures: %d\n", d.set.Size())
	fmt.Printf("Analyze Files: %d\n", d.size())
	fmt.Printf("Access to recently date?: %t\n", d.isInternet)
	// fmt.Printf("List skip DIR: %v\n", skipDIR)
}

func (d *Detection) size() int {
	return len(d.hashes)
}

func (d *Detection) exec() error {
	var err error
	if err = d.analyze(); err != nil {
		return err
	}
	if err = d.output(); err != nil {
		return err
	}
	return nil
}

func Ping() bool {
	resp, err := http.Get(PING_URL_OF_ITEASY_MISP)
	if err != nil {
		return false
	}

	if resp.StatusCode == 200 {
		return true
	}

	return false
}

func Today() string {
	loc, err := time.LoadLocation("Asia/Seoul")
	if err != nil {
		return "log"
	}

	// ÌòÑÏû¨ ÏãúÍ∞ÑÏùÑ ÌïúÍµ≠ ÏãúÍ∞ÑÎåÄÎ°ú ÏÑ§Ï†ï
	now := time.Now().In(loc)
	return now.Format("2006-01-02")
}

func getResult(score int) string {
	switch {
	case score >= 100:
		return DEFINITELY
	case score >= 90:
		return ALMOST_CERTAINLY
	case score >= 70:
		return PROBABLY
	case score >= 50:
		return MAYBE
	default:
		return DOUBTFULLY
	}
}

// DEBUG
func Info(debug iDebugger) {
	println("# # # # # # DEBUG MODE INFO # # # # # # # ")
	debug.info()
}

// BANNER
func Banner() {
	fmt.Printf("‚úÖ Target Path: %s\n", targetPath)
	fmt.Printf("‚úÖ Output Path: %s\n", outputPath)
}

func Spin(title string, process iSpin) {
	s := spin.New()     // ÏÉàÎ°úÏö¥ Ïä§ÌîºÎÑà ÏÉùÏÑ±
	s.Set(spin.Default) // ÏõêÌïòÎäî Ïä§ÌÉÄÏùº ÏÑ§Ï†ï (Í∏∞Î≥∏ Ïä§ÌÉÄÏùº ÏÇ¨Ïö© Í∞ÄÎä•)

	done := make(chan bool) // ÌîÑÎ°úÏÑ∏Ïä§ ÏôÑÎ£åÎ•º ÏïåÎ¶¨Îäî Ï±ÑÎÑê

	// Ïä§ÌîºÎÑàÎ•º Î≥ÑÎèÑ Í≥†Î£®Ìã¥ÏóêÏÑú Ïã§Ìñâ
	go func() {
		for {
			select {
			case <-done:
				return // ÏôÑÎ£åÎêòÎ©¥ Í≥†Î£®Ìã¥ Ï¢ÖÎ£å
			default:
				fmt.Printf("\rüîÅ \033[36m%s\033[m %s", title, s.Next()) // Ïä§ÌîºÎÑà Ïï†ÎãàÎ©îÏù¥ÏÖò
				time.Sleep(100 * time.Millisecond)                     // ÏÜçÎèÑ Ï°∞Ï†à
			}
		}
	}()

	if err := process.exec(); err != nil {
		panic(err)
	}

	time.Sleep(3 * time.Second)

	// ÏôÑÎ£å ÌõÑ Ïä§ÌîºÎÑà Ï†ïÎ¶¨
	done <- true
	fmt.Printf("\r‚úÖ \033[36m%s\033[m \033[36m%s\033[m\n", title, "Done.")
}

type SpinAdapter struct {
	detection iDetection
	action    func(iDetection) error
}

func NewSpinAdapter(d iDetection, action func(iDetection) error) *SpinAdapter {
	return &SpinAdapter{
		detection: d,
		action:    action,
	}
}

func (s *SpinAdapter) exec() error {
	return s.action(s.detection)
}

type InfoAdapter struct {
	detection iDetection
}

func NewInfoAdapter(d iDetection) *InfoAdapter {
	return &InfoAdapter{
		detection: d,
	}
}

func (i *InfoAdapter) info() {
	i.detection.info()
}

func Run(runner iDetection) {
	Spin("Initializing...", NewSpinAdapter(runner, iDetection.init))
	Spin("Analyzing...", NewSpinAdapter(runner, iDetection.analyze))
	Spin("Writing Logs...", NewSpinAdapter(runner, iDetection.output))
	// Info(NewInfoAdapter(runner)) // TODO: Ï∂îÍ∞ÄÏ†ÅÏù∏ Í≤∞Í≥ºÍ∞íÏùÑ Ï∂úÎ†•Ìï¥Î≥¥Ïûê.
}

func main() {
	rootCmd := &cobra.Command{
		Use:   fmt.Sprintf(InfoColor, APP_NAME),
		Short: fmt.Sprintf("%s:%s issued by %s. Created at %s", fmt.Sprintf(InfoColor, APP_NAME), VERSION, ISSUER, CREATEDAT),
		Run: func(cmd *cobra.Command, args []string) {

			Banner()

			runner := NewDetection(targetPath)

			Run(runner)
			// Debug
			if isDebug {
				Info(runner)
			}
		},
	}

	rootCmd.Flags().StringVarP(&targetPath, "path", "p", "./", "Í≤ÄÏÇ¨Ìï† ÌååÏùº ÎòêÎäî ÎîîÎ†âÌÑ∞Î¶¨ Í≤ΩÎ°ú")
	rootCmd.Flags().StringVarP(&outputPath, "output", "o", fmt.Sprintf("%s.csv", Today()), "Î°úÍ∑∏ ÌååÏùº Í≤ΩÎ°ú (Í∏∞Î≥∏Í∞í: ÌòÑÏû¨ ÎÇ†Ïßú Í∏∞Î∞ò, ÎÇ†Ïßú ÏóêÎü¨Ïãú result.csv)")
	rootCmd.Flags().BoolVarP(&isDebug, "debug", "d", false, "Enable Debug Mode. (default: false)")
	rootCmd.Flags().Int16VarP(&logLevel, "level", "l", LOG_LEVEL_IGNORE_NORMAL, "Î°úÍ∑∏ ÏûëÏÑ± Î†àÎ≤®. 0: Ï†ÑÏ≤¥, 1: Ï†ïÏÉÅ Ï†úÏô∏, 2: ÌôïÏã§Ìïú (default: 1)")
	// TODO: Ï∂îÌõÑ ÏóÖÎç∞Ïù¥Ìä∏
	// rootCmd.Flags().StringArrayVarP(&skipDIR, "skip", "s", make([]string, 0), "Í±¥ÎÑàÎõ∏ Ìè¥Îçî Î™©Î°ù. (default: [])")

	rootCmd.Execute()
}
